<!DOCTYPE html>
<html lang="en">

<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="description" content="jsbee" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" /> <!-- mobile-friendly -->
<title>jsbee</title>

<style>

  body {
    /* Light mode */
    color: black;
    background-color: white;
    /* Dark mode */
    /*
    color: white;
    background-color: black;
    */
    font-family: Verdana, sans-serif;
    font-size: 150%;
    letter-spacing: 0.25px;
    line-height: 125%;
  }
  h1 {
    font-weight: bold;
    color: maroon;
    font-size: 110%;
    text-align: center;
    margin: 40px;
  }
  h2 {
    font-weight: bold;
    color: maroon;
    font-size: 105%
  }
  h3 {
    font-weight: bold;
    color: maroon;
    font-size: 100%
  }

  a:link {
    color: maroon;
  }
  a:visited {
    color: maroon;
  }
  a:active {
    color: maroon;
  }

  input {
    font-weight: bold;
    color: black;
  }

  button {
    font-weight: bold;
    color: maroon;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }

  button:hover {
    font-weight: bold;
    background-color: #d8d8d8;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }

  button:active {
    font-weight: bold;
    background-color: #c0c0c0;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }

  .boxed-text {
    border: 1px solid black;
    padding-top: 4px;
    padding-bottom: 4px;
    padding-left: 8px;
    padding-right: 8px;
  }
  .center {
    text-align: center;
  }
  .maroon {
    color: maroon;
  }
  .boldmaroon {
    font-weight: bold;
    color: maroon;
  }

  .switch {
    position: relative;
    display: inline-block;
    width: 30px;
    height: 17px;
  }
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    -webkit-transition: .4s;
    transition: .4s;
  }
  .slider:before {
    position: absolute;
    content: "";
    height: 13px;
    width: 13px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
  }
  input:checked + .slider {
    background-color: #2196F3;
  }
  input:focus + .slider {
    box-shadow: 0 0 1px #2196F3;
  }
  input:checked + .slider:before {
    -webkit-transform: translateX(13px);
    -ms-transform: translateX(13px);
    transform: translateX(13px);
  }
  /* Rounded sliders */
  .slider.round {
    border-radius: 17px;
  }
  .slider.round:before {
    border-radius: 50%;
  }

</style>

</head>

<!-- ================================================================ -->
<body>

<h1><span class="boxed-text">jsbee</span></h1>

<table>
<tr>
  <td> <button class="maroon" id="jsbee-clear-letters-button"> Clear </button> </td>
  <td> <input type=text tabindex=1 placeholder="..." size=10 autocapitalize="characters" id="jsbee-required-letters"></input> </td>
  <td> Required letter(s) </td>
</tr>
<tr>
  <td> <button class="maroon" id="jsbee-example-button">UNINIT</button> </td>
  <td> <input type=text tabindex=2 placeholder="..." size=10 autocapitalize="characters" id="jsbee-other-letters"></input> </td>
  <td> Other letter(s) </td>
</tr>

<tr>
  <td> <button class="maroon" id="jsbee-all-others-button">UNINIT</button> </td>
  <td> &nbsp; </td>
  <td> &nbsp; </td>
</tr>

<tr>
  <td> &nbsp; </td>
  <td>
    <select tabindex=3 id="jsbee-word-list-dropdown">
      <option value="./usual-suspects.txt">Usual suspects</option>
      <option value="./long-list.txt">Long list</option>
    </select>
  </td>
  <td> Word list </td>
</tr>
<tr>
  <td> <button class="maroon" id="jsbee-reset-match-lengths-button"> Reset </button> </td>
  <td>
    <span>
      <input tabindex=4 type="number" id="jsbee-min-match-length" name="jsbee-min-match-length" min="1" max="16"/>
      <input tabindex=5 type="number" id="jsbee-max-match-length" name="jsbee-max-match-length" min="1" max="16"/>
    </span>
  </td>
  <td> <label for="jsbee-min-match-length">Minimum and maximum word lengths</label> </td>
</tr>

</table>

<p/>
<div>
  <button class="maroon" id="jsbee-output-show-hide-button"> Hide results </button>
</div>
<div>
  <span id="jsbee-output-count" style="display:none"> </span>
</div>
<div>
  <span id="jsbee-output" style="display:block"> </span>
</div>

<!-- ================================================================ -->
<hr/>

<div>
  Source and documentation: <a href="https://github.com/johnkerl/jsbee">https://github.com/johnkerl/jsbee</a>
</div>
<p/>

<div>
  <label class="switch">
    <input type="checkbox" id="jsbee-light-mode-dark-mode-toggle">
    <span class="slider round"></span>
  </label>
  <span id="jsbee-light-mode-dark-mode-label">UNINIT</span>
</div>
<p/>

<!-- ================================================================ -->
<script>
  'use strict';

  // ----------------------------------------------------------------
  // UTILITIES

  // TODO: assertor for non-null (e.g. get-element-by-id)

  function isInteger(text) {
    // TODO: this accepts '3.4' and should not
    return !isNaN(parseInt(text))
  }

  // ----------------------------------------------------------------
  // EXPERIMENTAL WIDGET CLASSES

  // TODO: move to a separate .js file

  class Slider {
    constructor(
      sliderElementID,
      labelElementID,
      isUncheckedLabel,
      isCheckedLabel,
      toUncheckedCallback,
      toCheckedCallback,
    ) {

      // Browser-model element by composition
      // * Underlying unchecked = slider left = light mode
      // * Underlying checked   = slider left = dark  mode
      this.underlyingSlider = document.getElementById(sliderElementID)
      this.underlyingLabel  = document.getElementById(labelElementID)
      // This lets underlying-level callbacks invoke our methods
      this.underlyingSlider.parent = this

      this.isUncheckedLabel    = isUncheckedLabel
      this.isCheckedLabel      = isCheckedLabel
      this.toUncheckedCallback = toUncheckedCallback
      this.toCheckedCallback   = toCheckedCallback

      this.underlyingSlider.addEventListener("change", function(e) {
        let obj = this.parent // Map from browser-level up to class-level
        if (this.checked) { // Here, this is the underlying, and this.checked is the new state
          obj.toChecked(e)
        } else {
          obj.toUnchecked(e)
        }
      })
    }

    // Set the browser-level elements we control
    toUnchecked(e) {
      this.toUncheckedCallback(e)
      this.underlyingLabel.textContent = this.isUncheckedLabel
      this.underlyingSlider.checked = false
    }
    toChecked(e) {
      this.toCheckedCallback(e)
      this.underlyingLabel.textContent = this.isCheckedLabel
      this.underlyingSlider.checked = true
    }
  }

  class PersistentSlider extends Slider {
    // Uses local storage to remember the state of the slider

    constructor(
      sliderElementID,
      labelElementID,
      isUncheckedLabel,
      isCheckedLabel,
      toUncheckedCallback,
      toCheckedCallback,
    ) {

      super(
        sliderElementID,
        labelElementID,
        isUncheckedLabel,
        isCheckedLabel,
        toUncheckedCallback,
        toCheckedCallback,
      )

      this.localStorageKey = document.URL + ":" + sliderElementID + ":checked"

      // Restore previous state upon construction
      if (localStorage.getItem(this.localStorageKey) == "true") {
        this.toChecked(null)
      } else {
        this.toUnchecked(null)
      }
    }

    // Remember last-set state
    toUnchecked(e) {
      super.toUnchecked(e)
      localStorage.setItem(this.localStorageKey, "false")
    }
    toChecked(e) {
      super.toChecked(e)
      localStorage.setItem(this.localStorageKey, "true")
    }
  }

  class LightDarkModeSlider extends PersistentSlider {
    // Lightly decorates PersistentSlider by adding labels
    constructor(sliderElementID, labelElementID, lightenCallback, darkenCallback) {
      super(
        sliderElementID,
        labelElementID,
        "Switch to dark mode",
        "Switch to light mode",
        lightenCallback,
        darkenCallback,
      )
    }
  }

  class Button {
    constructor(
      elementID,
      text,
      callback,
    ) {
      // Browser-model element by composition
      this.underlying = document.getElementById(elementID)
      // This lets underlying-level callbacks invoke our methods
      this.underlying.parent = this
      this.callback = callback

      this.underlying.textContent = text

      this.underlying.addEventListener("click", function(e) {
        let obj = this.parent // Map from browser-level up to class-level
        obj.callback(e)
      })
    }
  }

  // ----------------------------------------------------------------
  // APPLICATION STATE

  class JSBeeApp {

    constructor() {

      this.state = {
        "logLevel": 0, // 0,1,2,3
        "defaultMinMatchLength": 4,
        "defaultMaxMatchLength": 16,
        "minMatchLength": 4,
        "maxMatchLength": 16,
        "wordListURL": null,
        "wordList": null,
        "outputHidden": false,
      }

      this.setElementsAndCallbacks()

      this.elements.minMatchLengthElement.value = this.state.defaultMinMatchLength
      this.elements.maxMatchLengthElement.value = this.state.defaultMaxMatchLength

      this.state.minMatchLength = this.state.defaultMinMatchLength
      this.state.maxMatchLength = this.state.defaultMaxMatchLength
      this.setWordList(this.elements.wordListDropdown.value)

      this.elements.requiredLettersElement.focus()

    }

    setElementsAndCallbacks() {
      this.elements = {

        "requiredLettersElement":  document.getElementById("jsbee-required-letters"),
        "otherLettersElement":     document.getElementById("jsbee-other-letters"),

        "wordListDropdown":        document.getElementById("jsbee-word-list-dropdown"),

        "minMatchLengthElement":   document.getElementById("jsbee-min-match-length"),
        "maxMatchLengthElement":   document.getElementById("jsbee-max-match-length"),

        "clearLettersButton": new Button(
          "jsbee-clear-letters-button",
          "Clear",
          () => {
            this.logAt1("CLEAR-LETTERS BUTTON WAS CLICKED")
            this.elements.requiredLettersElement.value = ""
            this.elements.otherLettersElement.value = ""
            this.showMatches()
          },
        ),

        "exampleButton": new Button(
          "jsbee-example-button",
          "Example",
          () => {
            this.logAt1("EXAMPLE BUTTON WAS CLICKED")
            this.setExample()
            this.showMatches()
          },
        ),

        "allOthersButton": new Button(
          "jsbee-all-others-button",
          "A-Z",
          () => {
            this.logAt1("A-Z BUTTON WAS CLICKED")
            this.setAllOthers()
            this.showMatches()
          },
        ),

        "resetMatchLengthsButton": document.getElementById("jsbee-reset-match-lengths-button"),

        "outputShowHideButton":    document.getElementById("jsbee-output-show-hide-button"),
        "outputCountElement":      document.getElementById("jsbee-output-count"),
        "outputElement":           document.getElementById("jsbee-output"),

        "lightDarkModeElement": new LightDarkModeSlider(
          "jsbee-light-mode-dark-mode-toggle",
          "jsbee-light-mode-dark-mode-label",
          () => {
            document.body.style.backgroundColor = "white"
            document.body.style.color = "black"
          },
          () => {
            document.body.style.backgroundColor = "black"
            document.body.style.color = "white"
          },
        )
      }

      this.elements.requiredLettersElement.addEventListener("input", function(event) {
        app.logAt1("REQUIRED-LETTERS INPUT: <<", event.target.value, ">>")
        this.value = event.target.value.toUpperCase()
        app.showMatches()
      })

      this.elements.otherLettersElement.addEventListener("input", function(event) {
        app.logAt1("OTHER-LETTERS INPUT: <<", event.target.value, ">>")
        this.value = event.target.value.toUpperCase()
        app.showMatches()
      })

      this.elements.wordListDropdown.addEventListener("change", function() {
        let url = this.value
        app.logAt1("SELECTED WORD LIST: <<", url, ">>")
        app.setWordList(url)
        app.showMatches()
      })

      this.elements.minMatchLengthElement.addEventListener("change", function(event) {
        app.logAt1("MIN LENGTH CHANGE", event.target.value, "; CURRENT", app.state.minMatchLength, app.state.maxMatchLength)

        // The up-and-down sliders won't let the user choose outside the widget's min/max.
        // But the user can still type "999" or "aaa" into the widget. Here we protect against this.
        if (!isInteger(event.target.value)) {
          this.value = this.defaultValue
          app.state.minMatchLength = this.value
          app.showMatches()
          return;
        }
        let requestedValue = Number(event.target.value)

        // Check self-bounds
        if (requestedValue < this.min) {
          app.state.minMatchLength = this.min
          this.value = this.min
        } else if (requestedValue > this.max) {
          app.state.minMatchLength = this.max
          this.value = this.max

        // Check other-bounds
        } else if (requestedValue > app.state.maxMatchLength) {
          this.value = app.state.maxMatchLength

        } else {
          app.state.minMatchLength = requestedValue
        }
        app.showMatches()
      })

      this.elements.maxMatchLengthElement.addEventListener("change", function(event) {
        app.logAt1("MAX LENGTH CHANGE", event.target.value, "; CURRENT", app.state.minMatchLength, app.state.maxMatchLength)

        // The up-and-down sliders won't let the user choose outside the widget's min/max.
        // But the user can still type "999" or "aaa" into the widget. Here we protect against this.
        if (!isInteger(event.target.value)) {
          this.value = this.defaultValue
          app.state.maxMatchLength = this.value
          app.showMatches()
          return;
        }
        let requestedValue = Number(event.target.value)

        // Check self-bounds
        if (requestedValue < this.min) {
          app.state.maxMatchLength = this.min
          this.value = this.min
        } else if (requestedValue > this.max) {
          app.state.maxMatchLength = this.max
          this.value = this.max

        // Check other-bounds
        } else if (requestedValue < app.state.minMatchLength) {
          this.value = app.state.minMatchLength

        } else {
          app.state.maxMatchLength = requestedValue
        }
        app.showMatches()
      })

      this.elements.resetMatchLengthsButton.addEventListener("click", function(event) {
        app.logAt1("RESET-MATCH-LENGTHS BUTTON WAS CLICKED")
        app.elements.minMatchLengthElement.value =  app.state.defaultMinMatchLength
        app.elements.maxMatchLengthElement.value =  app.state.defaultMaxMatchLength
        app.state.minMatchLength = app.state.defaultMinMatchLength
        app.state.maxMatchLength = app.state.defaultMaxMatchLength
        app.showMatches()
      })

      this.elements.outputShowHideButton.addEventListener("click", function(event) {
        app.logAt1("OUTPUT SHOW-HIDE BUTTON WAS CLICKED")
        if (app.state.outputHidden) {
          app.state.outputHidden = false
          this.textContent = "Hide results"
          app.elements.outputCountElement.style.display = "none"
          app.elements.outputElement.style.display = "block"
        } else {
          app.state.outputHidden = true
          this.textContent = "Show results"
          app.elements.outputCountElement.style.display = "block"
          app.elements.outputElement.style.display = "none"
        }
      })

    }

    checkWordList() {
      if (this.state.wordListURL == null) {
        this.elements.outputElement.textContent = "No word list set"
        return false
      }
      if (this.state.wordList == null) {
        this.elements.outputElement.textContent = "Failed to fetch word list from \"" + url + "\""
        return false
      }
      return true
    }

    setWordList(url) {
      this.logAt0("FETCHING WORD LIST FROM URL:", url)
      this.state.wordListURL = url
      fetch(url).then((response) => response.text().then((text) => {
        this.state.wordList = text.split("\n")
        // Must be called from this callback, since this is async
        this.showMatches()
      }))
    }

    showMatches() {
      if (!this.checkWordList()) {
        return
      }

      let requiredLetters = this.elements.requiredLettersElement.value
      let otherLetters = this.elements.otherLettersElement.value

      let matches = this.getMatchesFromWordList(requiredLetters, otherLetters)
      matches = matches.map(match => match.toUpperCase())
      matches = matches.sort()
      app.logAt2(matches)

      this.elements.outputCountElement.textContent = "(" + String(matches.length) + " hidden)"

      if (requiredLetters.length == 0 && otherLetters.length == 0) {
        this.elements.outputElement.textContent = ""
      } else if (matches.length == 0) {
        this.elements.outputElement.textContent = "(No matches)"
      } else {
        this.elements.outputElement.textContent = matches.join(" ")
      }
    }

    getMatchesFromWordList(requiredLetters, optionalLetters) {
      this.logAt1("MATCHER ENTER")
      this.logAt1("requiredLetters ", requiredLetters)
      this.logAt1("optionalLetters", optionalLetters)
      this.logAt1("wordList.length", this.state.wordList.length)
      this.logAt3("wordList", this.state.wordList)

      requiredLetters = requiredLetters.toLowerCase()
      optionalLetters = optionalLetters.toLowerCase()
      let matches = []
      this.state.wordList.forEach((word) => {
        app.logAt3("WORD <<", word, ">>")
        if (this.wordMatches(requiredLetters, optionalLetters, word)) {
          app.logAt2("MATCH", word)
          matches.push(word)
        }
      })
      return matches
    }

    wordMatches(requiredLetters, optionalLetters, word) {
      let allLetters = requiredLetters + optionalLetters
      if (this.state.minMatchLength != null && word.length < this.state.minMatchLength) {
        app.logAt3("-- match out 1: word", word, "with length", word.length, "less than min", this.state.minMatchLength)
        return false
      }
      if (this.state.maxMatchLength != null && word.length > this.state.maxMatchLength) {
        app.logAt3("-- match out 2: word", word, "with length", word.length, "more than max", this.state.maxMatchLength)
        return false
      }
      for (let i = 0; i < requiredLetters.length; i++) {
        let requiredLetter = requiredLetters[i]
        if (word.indexOf(requiredLetter) < 0) {
          app.logAt3("-- match out 3: word", word, "missing required letter", requiredLetter, "from", requiredLetters)
          return false
        }
      }
      for (let i = 0; i < word.length; i++) {
        let letter = word[i]
        if (allLetters.indexOf(letter) < 0) {
          app.logAt3("-- match out 4: word", word, "missing letter", letter, "from", allLetters)
          return false
        }
      }
      app.logAt2("-- match:", word)
      return true
    }

    setAllOthers() {
      this.elements.requiredLettersElement.value = ""
      this.elements.otherLettersElement.value = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      this.elements.outputElement.textContent = ""
    }

    setExample() {
      this.elements.requiredLettersElement.value = "E"
      this.elements.otherLettersElement.value = "XAMPLS"
      this.elements.outputElement.textContent = ""
    }

    // ----------------------------------------------------------------
    // LOGGING METHODS

    logAt0(...args) {
      this.logAt(0, ...args)
    }

    logAt1(...args) {
      this.logAt(1, ...args)
    }

    logAt2(...args) {
      this.logAt(2, ...args)
    }

    logAt3(...args) {
      this.logAt(3, ...args)
    }

    logAt(level, ...args) {
      if (this.state.logLevel >= level) {
        console.log(...args)
      }
    }

  }

  // ----------------------------------------------------------------
  const app = new JSBeeApp()

</script>
<!-- ================================================================ -->
</body>
</html>
