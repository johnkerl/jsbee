<!DOCTYPE html>
<html lang="en">

<head>

<!-- ================================================================ -->
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BZ8T9K9XYD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-BZ8T9K9XYD');
</script>
<!-- ================================================================ -->

<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<meta name="description" content="On-line word-finder app">
<meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- mobile-friendly -->
<meta name="keywords" content="word finder anagram search puzzle">

<title>JSBee</title>

<style>

  /* BODY */
  body {
    /* Light theme */
    color: black;
    background-color: white;
    /* Dark theme */
    /*
    color: white;
    background-color: black;
    */
    font-family: Verdana, sans-serif;
    font-size: 150%;
    letter-spacing: 0.25px;
    line-height: 125%;
  }
  h1 {
    font-weight: bold;
    color: maroon;
    font-size: 110%;
    text-align: center;
    margin: 40px;
  }
  h2 {
    font-weight: bold;
    color: maroon;
    font-size: 105%
  }
  h3 {
    font-weight: bold;
    color: maroon;
    font-size: 100%
  }
  a:link {
    color: maroon;
  }
  a:visited {
    color: maroon;
  }
  a:active {
    color: maroon;
  }

  .rounded {
    border-radius: 4px;
  }

  .larger-input-text {
    /*
    font-size: 100%;
    */
    font-size: 0.8em;
  }
  .boxed-text {
    border: 1px solid black;
    padding-top: 4px;
    padding-bottom: 4px;
    padding-left: 8px;
    padding-right: 8px;
  }
  .center {
    text-align: center;
  }
  .maroon {
    color: maroon;
  }

  /* TABLE */
  table {
    border: none;
  }
  /*
  for debug
  table {
    border: 1px solid;
    border-collapse: collapse;
    border-color: #808080;
  }
  td {
    border: 1px solid;
    border-collapse: collapse;
    border-color: #808080;
  }
  */

  .smallertext {
    font-size: 80%
  }

  /* ERROR-HANDLER */
  .error {
    color: red;
    background-color: white;
    padding: 10px;
    margin: 10px;
  }

  /* TEXT INPUTS */
  input {
    font-weight: bold;
    color: black;
  }

  /* BUTTONS */
  button {
    font-weight: bold;
    background-color: #e8e8e8;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }
  button:hover {
    font-weight: bold;
    background-color: #d8d8d8;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }
  button:active {
    font-weight: bold;
    background-color: #c0c0c0;
    border: 0;
    padding: 4px;
    border-radius: 4px;
    margin: 4px;
  }
  button.selected {
    font-weight: bold;
  }
  button.deselected {
    font-weight: normal;
  }
  button.no-margin {
    margin: none;
  }
  button.transparent {
    font-weight: normal;
    border: 0;
    background-color: transparent;
  }

  /* MODALS */
  /*
    There's a trick here (found on the web).
    * The modal background covers the *entire screen*.
    * The modal content is a little box within that.
    *
  */
  .modal-background {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Entire screen */
    height: 100%; /* Entire screen */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgb(0, 0, 0); /* Fallback color in case alpha channel isn't supported */
    background-color: rgba(0, 0, 0, 0.4); /* Black w/ opacity -- stuff "under" the modal is dimmed */
  }
  .modal-content {
    background-color: white;
    border-radius: 4px;
    margin: 15% auto; /* 15% from the top and centered */
    padding: 20px;
    border: 2px solid gray;
    width: 80%;
  }

  /* THEME SELECTOR */
  .switch {
    position: relative;
    display: inline-block;
    width: 30px;
    height: 17px;
  }
  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    -webkit-transition: .4s;
    transition: .4s;
  }
  .slider:before {
    position: absolute;
    content: "";
    height: 13px;
    width: 13px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
  }
  input:checked + .slider {
    background-color: #2196F3;
  }
  input:focus + .slider {
    box-shadow: 0 0 1px #2196F3;
  }
  input:checked + .slider:before {
    -webkit-transform: translateX(13px);
    -ms-transform: translateX(13px);
    transform: translateX(13px);
  }
  .slider.round {
    border-radius: 17px;
  }
  .slider.round:before {
    border-radius: 50%;
  }

</style>

<!-- ================================================================ -->
<script>
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script>
  try {
    var pageTracker = _gat._getTracker("UA-15651652-1");
    pageTracker._trackPageview();
  } catch(err) {
  }
</script>
<!-- ================================================================ -->

</head>

<!-- ================================================================ -->
<body>

<h1><span class="boxed-text rounded">JSBee</span></h1>

<!--
  This is a self-contained widget for error-text and cancel/X button.
  We use Sliver's setErrorWidget to route top-level errors here.
-->
<span id="error-container" class="error">
  <button
    class=transparent
    onClick='
      document.getElementById("error-container").style.display = "none";
      document.getElementById("error-text").innerHTML = "";
    '
  > &times; </button>
  <span id="error-text"> </span>
</span>

<!-- fieldset allows a nice legend, of which I enjoy the styling -->
<fieldset class="rounded">
  <legend>
    <button id="bee-mode-button" class="no-margin"> Loading ... </button>
    <button id="pattern-mode-button" class="no-margin"> Loading ... </button>
    <button id="anagram-mode-button" class="no-margin"> Loading ... </button>
    <button id="random-word-mode-button" class="no-margin"> Loading ... </button>
  </legend>
  <table>

  <!-- Row for bee mode -->
  <tr id="bee-mode-row-1">
    <td> <button class="maroon" id="clear-letters-button"> Loading ... </button> </td>
    <td>
      <input
        type=text
        tabindex=1
        placeholder="..."
        size=10
        autocapitalize="characters"
        id="bee-mode-required-letters"
        class="larger-input-text"
      ></input>
    </td>
    <td>&nbsp;</td>
    <td class="smallertext"> Required letter(s) </td>
  </tr>

  <!-- Row for bee mode -->
  <tr id="bee-mode-row-2">
    <td> <button class="maroon" id="example-button">Loading ...</button> </td>
    <td>
      <input
        type=text
        tabindex=2
        placeholder="..."
        size=10
        autocapitalize="characters"
        id="bee-mode-other-letters"
        class="larger-input-text"
      ></input>
    </td>
    <td>&nbsp;</td>
    <td class="smallertext"> Other letter(s) </td>
  </tr>

  <!-- Row for bee mode -->
  <tr id="bee-mode-row-3">
    <td> <button class="maroon" id="all-others-button">Loading ...</button> </td>
    <td> &nbsp; </td>
    <td>&nbsp;</td>
    <td> &nbsp; </td>
  </tr>

  <!-- Row for pattern mode -->
  <tr id="pattern-mode-row-1">
    <td> <button class="maroon" id="pattern-clear-letters-button"> Loading ... </button> </td>
    <td>
      <input
        type=text
        tabindex=1
        placeholder="..."
        size=10
        id="pattern-mode-letters"
        class="larger-input-text">
      </input>
    </td>
    <td> &nbsp; </td>
    <td class="smallertext"> Letters, including <code>.</code> and <code>*</code> </td>
  </tr>

  <!-- Row for anagram mode -->
  <tr id="anagram-mode-row-1">
    <td> <button class="maroon" id="anagram-clear-letters-button"> Loading ... </button> </td>
    <td>
      <input
        type=text
        tabindex=1
        placeholder="..."
        size=10
        id="anagram-mode-letters"
        class="larger-input-text">
      </input>
    </td>
    <td> &nbsp; </td>
    <td class="smallertext"> Letters </td>
  </tr>

  <!-- Row for random-word mode -->
  <tr id="random-word-mode-row-1">
    <td> <button class="maroon" id="random-word-generate-button"> Loading ... </button> </td>
    <td>
      <input type="number" id="random-word-count">
    </td>
    <td> &nbsp; </td>
    <td class="smallertext"> Word count </td>
  </tr>

  <!-- Word list used by all modes -->
  <tr>
    <td> &nbsp; </td>
    <td>
      <select tabindex=3 id="word-list-dropdown">
        <!-- TODO: init the options in JS or HTML? -->
        <option value="./usual-suspects.txt">Usual suspects</option>
        <option value="./words-10K.txt">10K</option>
        <option value="./words-20K-cumulative.txt">20K</option>
        <option value="./words-30K-cumulative.txt">30K</option>
        <option value="./words-40K-cumulative.txt">40K</option>
        <option value="./long-list.txt">300K</option>
        <option value="./finnegans-words.txt">Finnegan</option>
      </select>
    </td>
    <td>&nbsp;</td>
    <td class="smallertext"> Word list </td>
  </tr>

  <!-- Min/max word lengths used by bee and pattern modes, but not anagram mode or random-word -->
  <tr id="match-lengths-row">
    <td> <button class="maroon" id="reset-match-lengths-button"> Reset </button> </td>
    <td>
      <span>
        <input tabindex=4 type="number" id="min-match-length" name="min-match-length" min="1" max="30"/>
        <input tabindex=5 type="number" id="max-match-length" name="max-match-length" min="1" max="30"/>
      </span>
    </td>
    <td>&nbsp;</td>
    <td class="smallertext"> <label for="min-max-match-length-label">Min/max word lengths</label> </td>
  </tr>

  <tr>
    <td>
      <div>
        <button id="bee-mode-help-launcher-button"> Help </button>
        <button id="pattern-mode-help-launcher-button"> Help </button>
        <button id="anagram-mode-help-launcher-button"> Help </button>
        <button id="random-word-mode-help-launcher-button"> Help </button>
      </div>
    </td>
    <td> &nbsp; </td>
    <td> &nbsp; </td>
  </tr>

  </table>
</fieldset>

<p/>
<div>
  <button class="maroon" id="output-show-hide-button"> Loading ... </button>
</div>
<div>
  <span id="output" style="display:block"> Loading ... </span>
</div>
<div>
  <span id="output-count" style="display:none"> Loading ... </span>
</div>

<!-- ================================================================ -->
<hr/>

<div class=smallertext>
  Source and documentation: <a href="https://github.com/johnkerl/jsbee">https://github.com/johnkerl/jsbee</a>
</div>
<p/>

<div class=smallertext>
  <label class="switch">
    <input type="checkbox" id="light-theme-dark-theme-toggle">
    <span class="slider round"></span>
  </label>
  <span id="light-theme-dark-theme-label">Loading ...</span>
</div>
<p/>

<!-- ================================================================ -->

<!-- Modal content -->
<div id="bee-mode-help-background" class="modal-background">
  <div id="bee-mode-help-content" class="modal-content">
    <div>
      <button id="bee-mode-help-close-button" class="general white-on-green" > Close </button>
    </div>
    <div>

    <p>Help for bee mode:</p>

      <p>Enter your required letters and your other letters. (For the NYT Spelling Bee,
      this will be the center letter and the surrounding letters, respectively.)

      <p>Choose the word list from the dropdown.</p>
      <ul>

        <li><i>Usual suspects</i> is a short, curated list of once-bitten-twice-shy values from
        previous Bees.</li>

        <li><i>Long list</i> contains over 300,000 words, not all of which are in the NYT Spelling
        Bee. (That is, this app can show words that the NYT Spelling Bee doesn&rsquo;t accept.)</li>

      </ul>

      <p>The output shown will include all words from the selected word list which contain only your
      required letters and your other letters:</p>
      <ul>

        <li>If the required letter is <code>P</code> and the other letters are <code>AELM</code>,
        then you&rsquo;ll see <code>PALM</code> and <code>PALE</code> but not
        <code>MEAL</code>.</li>

        <li>If the required letter is <code>M</code> and the other letters are <code>AELP</code>,
        then you&rsquo;ll see <code>MALL</code> and <code>MEAL</code> but not
        <code>PALE</code>.</li>

        <li>If the required letters are left empty and the other letters are <code>AELPM</code>,
        then you&rsquo;ll see words including <code>MALL</code>, <code>MEAL</code>,
        <code>PALE</code>, <code>MAPLE</code>, and <code>EEL</code>.  </li>

      </ul>

      <p> You can further restrict your results by setting minimum and maximum word lengths.

    </div>
  </div>
</div>

<div id="pattern-mode-help-background" class="modal-background">
  <div id="pattern-mode-help-content" class="modal-content">
    <div>
      <button id="pattern-mode-help-close-button" class="general white-on-green" > Close </button>
    </div>
    <div>

    <p>Help for pattern mode:</p>

    <p> Enter your desired letters in the <code>Letters</code> field.</p>

    <p> Select the word list you want to search in.</p>

    <p> You can use a <code>.</code> as a wildcard to match any single letter. For example, <code>LE.T</code>
    matches <code>LEFT</code>, <code>LENT</code>, <code>LEST</code>, etc.</p>

    <p> You can use a <code>*</code> as a wildcard to match zero or more of any letter. For example:</p>
    <ul>
      <li><code>OBOLUS</code> shows the one word <code>OBOLUS</code>, as a dictionary lookup</li>
      <li><code>THR*</code> shows all words that begin with <code>THR</code></li>
      <li><code>*EST</code> shows all words that end with <code>EST</code></li>
      <li><code>TH*TH</code> shows all words that begin and end with <code>TH</code> and</li>
      <li><code>*NIMB*</code> shows all words that have the sequence <code>NIMB</code> anywhere within.</li>
    </ul>

    <p> You can further restrict your results by setting minimum and maximum word lengths. </p>

    </div>
  </div>
</div>

<div id="anagram-mode-help-background" class="modal-background">
  <div id="anagram-mode-help-content" class="modal-content">
    <div>
      <button id="anagram-mode-help-close-button" class="general white-on-green" > Close </button>
    </div>
    <div>

    <p>Help for anagram mode:</p>

    <p> Enter your desired letters in the <code>Letters</code> field.</p>

    <p> Select the word list you want to search in.</p>

    <p> Results shown will be <a href="https://en.wikipedia.org/wiki/Anagram">anagrams</a> of the
    letters you provide. For example, ELATES will match SEALET but not ELATE or SEALETS.  </p>

    </div>
  </div>
</div>

<div id="random-word-mode-help-background" class="modal-background">
  <div id="random-word-mode-help-content" class="modal-content">
    <div>
      <button id="random-word-mode-help-close-button" class="general white-on-green" > Close </button>
    </div>
    <div>

    <p>Help for random-word mode:</p>

    <ul>
      <li> Select the word list </li>
      <li> Select how many words to generate at a time </li>
      <li> Use the Generate button to get a new random sample </li>
    </ul>

    </div>
  </div>
</div>

<!-- ================================================================ -->
<script type=module>
  'use strict';

  import {
    Button,
    ConstrainedTextInput,
    GenericElement,
    IntRangeInput,
    LightDarkThemeSlider,
    OneButtonSwitcher,
    PersistentDropdown,
    PersistentNButtonSwitcher,
    TextSpan,
    isInteger,
    setErrorWidget,
  // } from "http://127.0.1:9999/sliver/dev/sliver.js"
  // npx http-server ~/pub_http_internet -o -p 9999
  // } from "https://johnkerl.org/sliver/staging/sliver.js"
  // } from "https://johnkerl.org/sliver/stable/sliver.js"
  } from "./sliver.js" // local copy

  setErrorWidget("error-container", "error-text")

  // ----------------------------------------------------------------
  class JSBeeApp {

    constructor() {

      this.state = {
        "logLevel": 0, // 0,1,2,3

        "defaultLowMatchLength": 4,
        "defaultHighMatchLength": 16,
        "minMatchLength": 1,
        "maxMatchLength": 30,

        "defaultRandomWordCount": 5,
        "minRandomWordCount": 1,
        "maxRandomWordCount": 100,

        "defaultNgramN": 4,
        "minNgramN": 1,
        "maxNgramN": 7,

        "defaultNgramWordCount": 5,
        "minNgramWordCount": 1,
        "maxNgramWordCount": 100,

        "wordListURL": null,
        "wordList": null,
        "wordListForAnagramMode": null, // Letters are sorted within words
      }

      this.setElementsAndCallbacks()
      this.setWordList(this.elements.wordListDropdown.get())
      if (this.elements.modeButtons.which() == 'bee-mode-button') {
        this.elements.requiredLettersElement.focus()
      } else {
        this.elements.patternLettersElement.focus()
      }

    }

    setElementsAndCallbacks() {
      this.elements = {}

      this.elements.outputElement = new TextSpan("output", "")
      this.elements.outputCountElement = new TextSpan("output-count", "")

      // Bee-mode element
      this.elements.requiredLettersElement = new ConstrainedTextInput(
        "bee-mode-required-letters",
        (text) => text.toUpperCase(),
        //(text) => text,
        (event) => {
          this.logAt1("REQUIRED-LETTERS INPUT: <<", event.target.value, ">>")
          this.showBeeModeMatches()
      })

      // Bee-mode element
      this.elements.otherLettersElement = new ConstrainedTextInput(
        "bee-mode-other-letters",
        (text) => text.toUpperCase(),
        //(text) => text,
        (event) => {
          this.logAt1("OTHER-LETTERS INPUT: <<", event.target.value, ">>")
          this.showBeeModeMatches()
      })

      // Pattern-mode element
      this.elements.patternLettersElement = new ConstrainedTextInput(
        "pattern-mode-letters",
        //(text) => text.toUpperCase(),
        (text) => text,
        (event) => {
          this.logAt1("PATTERN-LETTERS INPUT: <<", event.target.value, ">>")
          this.showPatternModeMatches()
      })

      // Anagram-mode element
      this.elements.anagramLettersElement = new ConstrainedTextInput(
        "anagram-mode-letters",
        //(text) => text.toUpperCase(),
        (text) => text,
        (event) => {
          this.logAt1("ANAGRAM-LETTERS INPUT: <<", event.target.value, ">>")
          this.showAnagramModeMatches()
      })

      this.elements.wordListDropdown = new PersistentDropdown(
        "word-list-dropdown",
        (event) => {
          let url = event.target.value
          this.logAt1("SELECTED WORD LIST: <<", url, ">>")
          this.setWordList(url)
          this.showMatches()
      })

      let minMatchLengthElement = new IntRangeInput(
        "min-match-length",
        this.state.defaultLowMatchLength, // default
        this.state.minMatchLength, // min
        this.state.maxMatchLength, // max
        (event) => {
          this.showMatches()
        },
      )

      let maxMatchLengthElement = new IntRangeInput(
        "max-match-length",
        this.state.defaultHighMatchLength, // default
        this.state.minMatchLength, // min
        this.state.maxMatchLength, // max
        (event) => {
          this.showMatches()
        },
      )

      // TODO: do this coupling at the class level -- IntRangeInputPair maybe -- with resetter
      minMatchLengthElement.setPeerMax(maxMatchLengthElement)
      maxMatchLengthElement.setPeerMin(minMatchLengthElement)

      this.elements.minMatchLengthElement = minMatchLengthElement
      this.elements.maxMatchLengthElement = maxMatchLengthElement

      // Bee-mode element
      this.elements.clearLettersButton = new Button(
        "clear-letters-button",
        "Clear",
        (event) => {
          this.logAt1("CLEAR-LETTERS BUTTON WAS CLICKED")
          this.elements.requiredLettersElement.set("")
          this.elements.otherLettersElement.set("")
          this.showBeeModeMatches()
        },
      )

      // Bee-mode element
      this.elements.exampleButton = new Button(
        "example-button",
        "Example",
        (event) => {
          this.logAt1("EXAMPLE BUTTON WAS CLICKED")

          this.elements.requiredLettersElement.set("E")
          this.elements.otherLettersElement.set("XAMPLS")
          this.elements.outputElement.set("")

          this.showBeeModeMatches()
        },
      )

      // Bee-mode element
      this.elements.allOthersButton = new Button(
        "all-others-button",
        "A-Z",
        (event) => {
          this.logAt1("A-Z BUTTON WAS CLICKED")

          this.elements.requiredLettersElement.set("")
          this.elements.otherLettersElement.set("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
          this.elements.outputElement.set("")

          this.showBeeModeMatches()
        },
      )

      // Pattern-mode element
      this.elements.patternClearLettersButton = new Button(
        "pattern-clear-letters-button",
        "Clear",
        (event) => {
          this.logAt1("PATTERN-CLEAR-LETTERS BUTTON WAS CLICKED")
          this.elements.patternLettersElement.set("")
          this.showPatternModeMatches()
        },
      )

      // Anagram-mode element
      this.elements.anagramClearLettersButton = new Button(
        "anagram-clear-letters-button",
        "Clear",
        (event) => {
          this.logAt1("ANAGRAM-CLEAR-LETTERS BUTTON WAS CLICKED")
          this.elements.anagramLettersElement.set("")
          this.showAnagramModeMatches()
        },
      )

      // Random-word-mode element
      this.elements.randomWordGenerateButton = new Button(
        "random-word-generate-button",
        "Generate",
        (event) => {
          this.logAt1("RANDOM-WORD-GENERATE BUTTON WAS CLICKED")
          this.generateRandomWords()
        },
      )

      // Random-word-mode element
      this.elements.randomWordCountInput = new IntRangeInput(
        "random-word-count",
        this.state.defaultRandomWordCount, // default
        this.state.minRandomWordCount, // min
        this.state.maxRandomWordCount, // max
        (event) => {
          this.generateRandomWords()
        },
      )

      this.elements.resetMatchLengthsButton = new Button(
        "reset-match-lengths-button",
        "Reset",
        (event) => {
          this.logAt1("RESET-MATCH-LENGTHS BUTTON WAS CLICKED")
          this.elements.minMatchLengthElement.resetToDefault(),
          this.elements.maxMatchLengthElement.resetToDefault(),
          this.showMatches()
        },
      )

      this.outputShowHideButton = new OneButtonSwitcher(
        "output-show-hide-button",
        [this.elements.outputElement],
        [this.elements.outputCountElement],
        "Hide results",
        "Show results",
        () => {},
      )

      this.elements.matchLengthsRow = new GenericElement("match-lengths-row")

      this.elements.modeButtons = new PersistentNButtonSwitcher( {

          "bee-mode-button": {
            "text": "Bee",
            "items": [
              new GenericElement("bee-mode-row-1"),
              new GenericElement("bee-mode-row-2"),
              new GenericElement("bee-mode-row-3"),
              new GenericElement("bee-mode-help-launcher-button"),
            ],
            "callback": () => {
              this.elements.matchLengthsRow.makeVisible()
              this.elements.requiredLettersElement.focus()
              this.showMatches()
            },
          },

          "pattern-mode-button": {
            "text": "Pattern",
            "items": [
              new GenericElement("pattern-mode-row-1"),
              new GenericElement("pattern-mode-help-launcher-button"),
            ],
            "callback": () => {
              this.elements.matchLengthsRow.makeVisible()
              this.elements.patternLettersElement.focus()
              this.showMatches()
            },
          },

          "anagram-mode-button": {
            "text": "Anagram",
            "items": [
              new GenericElement("anagram-mode-row-1"),
              new GenericElement("anagram-mode-help-launcher-button"),
            ],
            "callback": () => {
              this.elements.matchLengthsRow.makeInvisible()
              this.elements.anagramLettersElement.focus()
              this.showMatches()
            },
          },

          "random-word-mode-button": {
            "text": "Random",
            "items": [
              new GenericElement("random-word-mode-row-1"),
              new GenericElement("random-word-mode-help-launcher-button"),
            ],
            "callback": () => {
              this.elements.matchLengthsRow.makeInvisible()
              this.generateRandomWords()
            },
          },

        },
        "selected",   // CSS style class
        "deselected", // CSS style class
      )

      // ----------------------------------------------------------------

      this.elements.bee_mode_help_background  = new GenericElement("bee-mode-help-background")
      this.elements.bee_mode_help_content  = new GenericElement("bee-mode-help-content")

      this.elements.bee_mode_help_launcherButton = new Button(
        "bee-mode-help-launcher-button",
        null,
        (event) => {
          this.elements.bee_mode_help_background.makeVisible("block")
          this.elements.bee_mode_help_background.underlying.style.display = "block"
        },
      )

      this.elements.bee_mode_help_close_button = new Button(
        "bee-mode-help-close-button",
        null,
        (event) => {
          this.elements.bee_mode_help_background.makeInvisible()
        },
      )

      // ----------------------------------------------------------------
      this.elements.pattern_mode_help_background  = new GenericElement("pattern-mode-help-background")
      this.elements.pattern_mode_help_content  = new GenericElement("pattern-mode-help-content")

      this.elements.pattern_mode_help_launcherButton = new Button(
        "pattern-mode-help-launcher-button",
        null,
        (event) => {
          this.elements.pattern_mode_help_background.makeVisible("block")
          this.elements.pattern_mode_help_background.underlying.style.display = "block"
        },
      )

      this.elements.pattern_mode_help_close_button = new Button(
        "pattern-mode-help-close-button",
        null,
        (event) => {
          this.elements.pattern_mode_help_background.makeInvisible()
        },
      )

      // ----------------------------------------------------------------
      this.elements.anagram_mode_help_background  = new GenericElement("anagram-mode-help-background")
      this.elements.anagram_mode_help_content  = new GenericElement("anagram-mode-help-content")

      this.elements.anagram_mode_help_launcherButton = new Button(
        "anagram-mode-help-launcher-button",
        null,
        (event) => {
          this.elements.anagram_mode_help_background.makeVisible("block")
          this.elements.anagram_mode_help_background.underlying.style.display = "block"
        },
      )

      this.elements.anagram_mode_help_close_button = new Button(
        "anagram-mode-help-close-button",
        null,
        (event) => {
          this.elements.anagram_mode_help_background.makeInvisible()
        },
      )

      // ----------------------------------------------------------------
      this.elements.random_word_mode_help_background  = new GenericElement("random-word-mode-help-background")
      this.elements.random_word_mode_help_content  = new GenericElement("random-word-mode-help-content")

      this.elements.random_word_mode_help_launcherButton = new Button(
        "random-word-mode-help-launcher-button",
        null,
        (event) => {
          this.elements.random_word_mode_help_background.makeVisible("block")
          this.elements.random_word_mode_help_background.underlying.style.display = "block"
        },
      )

      this.elements.random_word_mode_help_close_button = new Button(
        "random-word-mode-help-close-button",
        null,
        (event) => {
          this.elements.random_word_mode_help_background.makeInvisible()
        },
      )

      // ----------------------------------------------------------------
      // XXX TEMP HACK
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          window.app.elements.bee_mode_help_background.makeInvisible()
          window.app.elements.pattern_mode_help_background.makeInvisible()
          window.app.elements.anagram_mode_help_background.makeInvisible()
          window.app.elements.random_word_mode_help_background.makeInvisible()
        }
      });

      // ----------------------------------------------------------------
      this.elements.lightDarkThemeElement = new LightDarkThemeSlider(
        "light-theme-dark-theme-toggle",
        "light-theme-dark-theme-label",
        (event) => {
          document.body.style.backgroundColor = "white"
          document.body.style.color = "black"
          this.elements.bee_mode_help_content.underlying.style.backgroundColor = "white"
          this.elements.bee_mode_help_content.underlying.style.color = "black"
          this.elements.pattern_mode_help_content.underlying.style.backgroundColor = "white"
          this.elements.pattern_mode_help_content.underlying.style.color = "black"
          this.elements.anagram_mode_help_content.underlying.style.backgroundColor = "white"
          this.elements.anagram_mode_help_content.underlying.style.color = "black"
          this.elements.random_word_mode_help_content.underlying.style.backgroundColor = "white"
          this.elements.random_word_mode_help_content.underlying.style.color = "black"
        },
        (event) => {
          document.body.style.backgroundColor = "black"
          document.body.style.color = "white"
          this.elements.bee_mode_help_content.underlying.style.backgroundColor = "black"
          this.elements.bee_mode_help_content.underlying.style.color = "white"
          this.elements.pattern_mode_help_content.underlying.style.backgroundColor = "black"
          this.elements.pattern_mode_help_content.underlying.style.color = "white"
          this.elements.anagram_mode_help_content.underlying.style.backgroundColor = "black"
          this.elements.anagram_mode_help_content.underlying.style.color = "white"
          this.elements.random_word_mode_help_content.underlying.style.backgroundColor = "black"
          this.elements.random_word_mode_help_content.underlying.style.color = "white"
        },
      )

    }

    checkWordList() {
      if (this.state.wordListURL == null) {
        this.elements.outputElement.set("No word list set")
        return false
      }
      if (this.state.wordList == null) {
        this.elements.outputElement.set('Failed to fetch word list from "' + url + '"')
        return false
      }
      return true
    }

    setWordList(url) {
      // CORS make us unable to load ./anything when doing local-disk dev
      if (document.URL.startsWith("file://")) {
        this.state.wordListURL = "local-in-memory"
        this.state.wordList = [
          "abaci", "acacia", "acai", "acetate", "affiant", "aioli", "alfalfa", "alga", "algae", "algal",
          "allele", "ameba", "amoeba", "amoebae", "amyl", "anneal", "anyhoo", "apian", "apnea", "arancini",
          "arhat", "aria", "aril", "arnica", "atilt", "atria", "attaboy", "baaed", "baba", "babel", "babka",
          "bailiff", "banana", "bandana", "bandanna", "barbacoa", "blin", "blini", "boll", "bombe", "bonbon",
          "bonobo", "booboo", "bootee", "bootie", "bowwow", "cabala", "cabana", "cacao", "cacti", "caddie",
          "caddied", "caiman", "cairn", "calla", "callaloo", "cami", "cancan", "canid", "canna", "canola",
          "cantata", "canteen", "captcha", "carioca", "celeb", "celli", "cellule", "cetacean", "chai", "chia",
          "chic", "chica", "chichi", "ciao", "cirri", "coca", "cocci", "cocoa", "cocoon", "codon", "coho",
          "coir", "colcannon", "collab", "croon", "deicide", "ditto", "dorado", "dunno", "electee", "emcee",
          "emceed", "epee", "falafel", "fantail", "froufrou", "galangal", "gavage", "gelee", "gooey",
          "google", "googol", "gotta", "haka", "hake", "halal", "hamachi", "haram", "hatha", "hoodoo",
          "iambi", "icemen", "imam", "infill", "innie", "iota", "laic", "laical", "lallygag", "lanai",
          "lanolin", "lantana", "lavage", "libelee", "llano", "logroll", "lollygag", "lookback", "lookbook",
          "loonie", "luging", "lunula", "magma", "mahatma", "malic", "mama", "melee", "mentee", "minim",
          "momma", "muumuu", "naan", "nada", "naiad", "nana", "nankeen", "natant", "nene", "neocon", "niacin",
          "noncom", "nonillion", "nuncio", "oleo", "olio", "onion", "paean", "paella", "palapa", "pampa",
          "panini", "papa", "payee", "peahen", "peke", "pica", "pinniped", "pintail", "pipit", "pippin",
          "pitapat", "pooh", "poplin", "poppa", "powwow", "raffia", "raita", "rapini", "ratatat", "ribbit",
          "rococo", "tahini", "tali", "tannic", "tannin", "tantara", "tartan", "tartar", "tattoo", "tilth",
          "tinct", "titmice", "toccata", "tomtit", "toon", "toonie", "tori", "toric", "torii", "tutee",
          "tutti", "tutu", "undid", "vanilla", "vanillin", "woohoo",
        ]
        this.setWordListForAnagramMode()
        this.showMatches()
      } else {
        this.logAt0("FETCHING WORD LIST FROM URL:", url)
        this.state.wordListURL = url
        fetch(url).then((response) => response.text().then((text) => {
          this.state.wordList = text.split("\n")
          this.setWordListForAnagramMode()
          // Must be called from this callback, since this is all async
          this.showMatches()
        }))
      }
    }

    // Requires this.wordList to have already been computed.
    // This precomputes sorting each word by its letter, which is a performance optimization.
    setWordListForAnagramMode() {
      this.wordListForAnagramMode = {}
      this.state.wordList.forEach((word) => {
        this.wordListForAnagramMode[word] = word.split('').sort().join('')
      })
    }

    showMatches() {
      if (this.elements.modeButtons == null) {
        // At app initialization
        return
      }

      if (this.elements.modeButtons.which() == 'bee-mode-button') {
        this.showBeeModeMatches()
      } else if (this.elements.modeButtons.which() == 'pattern-mode-button') {
        this.showPatternModeMatches()
      } else if (this.elements.modeButtons.which() == 'anagram-mode-button') {
        this.showAnagramModeMatches()
      } else if (this.elements.modeButtons.which() == 'random-word-mode-button') {
        this.generateRandomWords()
      }
    }

    showBeeModeMatches() {
      if (!this.checkWordList()) {
        return
      }

      let requiredLetters = this.elements.requiredLettersElement.get()
      let otherLetters = this.elements.otherLettersElement.get()

      let matches = this.getBeeMatchesFromWordList(requiredLetters, otherLetters)
      matches = matches.map(match => match.toUpperCase())
      matches = matches.sort()
      this.logAt2(matches)

      this.elements.outputCountElement.set("(" + String(matches.length) + " hidden)")

      if (requiredLetters.length == 0 && otherLetters.length == 0) {
        this.elements.outputElement.set("")
      } else if (matches.length == 0) {
        this.elements.outputElement.set("(No matches)")
      } else {
        this.elements.outputElement.set(matches.join(" "))
      }
    }

    getBeeMatchesFromWordList(requiredLetters, optionalLetters) {
      this.logAt1("MATCHER ENTER")
      this.logAt1("requiredLetters ", requiredLetters)
      this.logAt1("optionalLetters", optionalLetters)
      this.logAt1("wordList.length", this.state.wordList.length)
      this.logAt3("wordList", this.state.wordList)

      requiredLetters = requiredLetters.toLowerCase()
      optionalLetters = optionalLetters.toLowerCase()
      let minMatchLength = this.elements.minMatchLengthElement.get()
      let maxMatchLength = this.elements.maxMatchLengthElement.get()
      let matches = []

      this.state.wordList.forEach((word) => {
        this.logAt3("WORD <<", word, ">>")
        if (this.wordBeeMatches(requiredLetters, optionalLetters, minMatchLength, maxMatchLength, word)) {
          this.logAt2("MATCH", word)
          matches.push(word)
        }
      })
      return matches
    }

    wordBeeMatches(requiredLetters, optionalLetters, minMatchLength, maxMatchLength, word) {
      let allLetters = requiredLetters + optionalLetters

      if (word.length < minMatchLength) {
        this.logAt3("-- match out 1: word", word, "with length", word.length, "less than min", minMatchLength)
        return false
      }
      if (word.length > maxMatchLength) {
        this.logAt3("-- match out 2: word", word, "with length", word.length, "more than max", maxMatchLength)
        return false
      }
      for (let i = 0; i < requiredLetters.length; i++) {
        let requiredLetter = requiredLetters[i]
        if (word.indexOf(requiredLetter) < 0) {
          this.logAt3("-- match out 3: word", word, "missing required letter", requiredLetter, "from", requiredLetters)
          return false
        }
      }
      for (let i = 0; i < word.length; i++) {
        let letter = word[i]
        if (allLetters.indexOf(letter) < 0) {
          this.logAt3("-- match out 4: word", word, "missing letter", letter, "from", allLetters)
          return false
        }
      }
      this.logAt2("-- match:", word)
      return true
    }

    regexify(patternLetters) {
      // Regex mapping:
      // o A-Z -> self
      // o . -> .
      // o * -> .*
      // o Wrap in ^ and $

      this.logAt1("REGEX IN ", patternLetters)
      let regexString = "^"
      let azre = new RegExp("^[A-Za-z]$")
      for (let i = 0; i < patternLetters.length; i++) {
        let patternLetter = patternLetters[i]
        this.logAt1("  REQLT", patternLetter)
        if (patternLetter == ".")  {
          regexString += "."
        } else if (patternLetter == "*")  {
          regexString += ".*"
        } else if (azre.exec(patternLetter)) {
          regexString += patternLetter.toLowerCase()
        }
      }
      regexString += "$"
      this.logAt1("REGEX OUT", regexString)

      return new RegExp(regexString)
    }

    showPatternModeMatches() {
      if (!this.checkWordList()) {
        return
      }
      let patternLetters = this.elements.patternLettersElement.get()

      let matches = this.getPatternMatchesFromWordList(patternLetters)
      // matches = matches.map(match => match.toUpperCase())
      matches = matches.sort()
      this.logAt2(matches)

      this.elements.outputCountElement.set("(" + String(matches.length) + " hidden)")
      if (patternLetters.length == 0) {
        this.elements.outputElement.set("")
      } else if (matches.length == 0) {
        this.elements.outputElement.set("(No matches)")
      } else {
        this.elements.outputElement.set(matches.join(" "))
      }
    }

    getPatternMatchesFromWordList(patternLetters) {
      this.logAt1("MATCHER ENTER")
      this.logAt1("patternLetters ", patternLetters)
      this.logAt1("wordList.length", this.state.wordList.length)
      this.logAt3("wordList", this.state.wordList)

      patternLetters = patternLetters.toLowerCase()
      let re = this.regexify(patternLetters)

      let matches = []
      let minMatchLength = this.elements.minMatchLengthElement.get()
      let maxMatchLength = this.elements.maxMatchLengthElement.get()
      this.state.wordList.forEach((word) => {
        if (word.length < minMatchLength) {
        } else if (word.length > maxMatchLength) {
        } else if (re.exec(word)) {
          matches.push(word)
        }
      })
      return matches
    }

    showAnagramModeMatches() {
      if (!this.checkWordList()) {
        return
      }
      let anagramLetters = this.elements.anagramLettersElement.get()

      let matches = this.getAnagramMatchesFromWordList(anagramLetters)
      //matches = matches.map(match => match.toUpperCase())
      matches = matches.sort()
      this.logAt2(matches)

      this.elements.outputCountElement.set("(" + String(matches.length) + " hidden)")
      if (anagramLetters.length == 0) {
        this.elements.outputElement.set("")
      } else if (matches.length == 0) {
        this.elements.outputElement.set("(No matches)")
      } else {
        this.elements.outputElement.set(matches.join(" "))
      }
    }

    getAnagramMatchesFromWordList(anagramLetters) {
      this.logAt1("MATCHER ENTER")
      this.logAt1("anagramLetters ", anagramLetters)
      this.logAt1("wordList.length", this.state.wordList.length)
      this.logAt3("wordList", this.state.wordList)

      let sortedInput = anagramLetters.toLowerCase().split('').sort().join('');

      let matches = []
      for (const [word, sortedWord] of Object.entries(this.wordListForAnagramMode)) {
        this.logAt3("-- matcher check", word, " vs ", anagramLetters)
        if (sortedWord == sortedInput) {
          matches.push(word)
        }
      }
      return matches
    }

    generateRandomWords() {
      if (!this.checkWordList()) {
        return
      }

      let matches = []
      // TODO: sample without replapcement.
      // In practice, dups are super-rare.
      let k = this.elements.randomWordCountInput.get()
      let n = this.state.wordList.length
      for (let i = 0; i < k; i++) {
          const randomIndex = Math.floor(Math.random() * n);
          let word = this.state.wordList[randomIndex]
          matches.push(word)
      }

      this.elements.outputCountElement.set("(" + String(matches.length) + " hidden)")
      this.elements.outputElement.set(matches.join(" "))
    }

    // ----------------------------------------------------------------
    // See for context
    // https://johnkerl.org/randspell/randspell-slides-ts.pdf

    // XXX make an ngram class

        //"defaultNgramN": 4,
        //"minNgramN": 1,
        //"maxNgramN": 7,

        //"defaultNgramWordCount": 5,
        //"minNgramWordCount": 1,
        //"maxNgramWordCount": 100,

//# Ingest words from the word-list file(s).
//for (_, word in $*) {
//  call ingest_word(word);
//}
//
//# Compute CMFs from histograms, for weighted sampling.
//end {
//  call compute_cmfs();
//  if (@verbose) {
//    dump;
//  }
//}
//
//# Emit words
//end {
//  for (int i = 0; i < @ocount; i += 1) {
//    str word = emit_word();
//    if (word == "") {
//      # Error message already printed out.
//      break;
//    }
//    print word;
//  }
//}
//
//# ================================================================
//# NGRAM STATE
//
//subr init() {
//  @len_histo    = {};
//  @start_histos = []; # Make this an array; auto-extend would make it a map
//}
//
//# ----------------------------------------------------------------
//subr ingest_word(str word) {
//  # Accumulate a histogram of word lengths, so when we're asked to emit words,
//  # we can emit them with word-lengths of this same distribution.
//  int wordlen = strlen(word);
//  if (wordlen < 1) {
//    return;
//  }
//  @len_histo[wordlen] += 1;
//
//  int from_begin = 1;
//  int from_end   = 0;
//  int to_index   = 1;
//
//  if (@verbose) {
//    print;
//    print "INGEST", word, wordlen;
//  }
//
//  # We are doing n-grams, so say with n=5, each 4 letter predicts the 5th.
//  # However at the start of a word we don't *have* 4 yet. So the starting
//  # histograms are for stats on the first few letters.
//  #
//  # * For picking the first letter we get stats on the (arbitrary) start symbol
//  #   "_" as mapping to the first letter.
//  # * Then stats on the first mapping to the second.
//  # * Then stats on the first & second mapping to the third.
//  # * Etc.
//  #
//  # Exammple: input word "abcdefghij" with n=5.
//  # * @start_histo[1] is { "_"   : { "a": 1 }}
//  # * @start_histo[2] is { "a"   : { "b": 1 }}
//  # * @start_histo[3] is { "ab"  : { "c": 1 }}
//  # * @start_histo[4] is { "abc" : { "d": 1 }}
//  for (i = 1; i < @n; i += 1) {
//    if (to_index > wordlen) {
//      return;
//    }
//    str from = "_";
//    if (to_index > 1) {
//      from = word[from_begin:from_end];
//    }
//    str to = word[to_index];
//    if (@verbose) {
//      print "START  [" . from_begin . ":" . from_end . " -> ". to_index . "]", from, "->", to;
//    }
//    @start_histos[i][from][to] += 1;
//
//    from_end += 1;
//    to_index += 1;
//  }
//
//  # Now we have n-1 letters for the "from" part followed by the 1 letter "to" part.
//  # Exammple: input word "abcdefghij" with n=5.
//  # * @middle_histo is {
//  #   "abcd"   : { "e": 1 },
//  #   "bcde"   : { "f": 1 },
//  #   "cdef"   : { "g": 1 },
//  #   "defg"   : { "h": 1 },
//  # }
//  # We don't get stats on "efgh" -> "i" since we track that separately in the word-ending histogram.
//  while (to_index < wordlen) {
//    str from = word[from_begin:from_end];
//    str to   = word[to_index];
//    if (@verbose) {
//      print "MIDDLE [" . from_begin . ":" . from_end . " -> ". to_index . "]", from, "->", to;
//    }
//    @middle_histo[from][to] += 1;
//
//    from_begin += 1;
//    from_end   += 1;
//    to_index   += 1;
//  }
//
//  if (to_index > wordlen) {
//    return;
//  }
//
//  # Word-ending histogram: separately tracks what words end in. Without this, it'd be easy
//  # to produce words like "childhoo" or somesuch, not matching *endings* of words in the input.
//  str from = word[from_begin:from_end];
//  str to   = word[to_index];
//  if (@verbose) {
//    print "END    [" . from_begin . ":" . from_end . " -> ". to_index . "]", from, "->", to;
//  }
//  @end_histo[from][to] += 1;
//}
//
//# ----------------------------------------------------------------
//# See ngfuncs.mlr. Here we simply turn the histograms into cumulative mass functions
//# which are convenient for sampling.
//#
//# Example: if the input list has first letter 'a' twice, 'b' once, and 'c' once, then
//# the histogram is 'a':2, 'b':1, 'c':1. The CMF is 'a':0.50, 'b':0.75, 'c':1.00.
//
//subr compute_cmfs() {
//  @len_cmf = compute_cmf_from_histo(@len_histo);
//
//  for (i = 1; i < @n; i += 1) {
//    for (from in @start_histos[i]) {
//      @start_cmfs[i][from] = compute_cmf_from_histo(asserting_map(@start_histos[i][from]))
//    }
//  }
//
//  for (from in @middle_histo) {
//    @middle_cmf[from] = compute_cmf_from_histo(asserting_map(@middle_histo[from]));
//  }
//
//  for (from in @end_histo) {
//    @end_cmf[from] = compute_cmf_from_histo(asserting_map(@end_histo[from]));
//  }
//}
//
//# ----------------------------------------------------------------
//# Splicing n-gram chains for start/middle of word with end-of-word data, doesn't always
//# connect. Hence the emit_word_aux helper function.
//func emit_word(): str {
//  int max_tries = 100;
//  for (i = 0; i < max_tries; i += 1) {
//    str word = emit_word_aux();
//    if (word != "") {
//      return word;
//    }
//  }
//  print "Could not generate ngram word after", max_tries, "tries.";
//  return "";
//}
//
//func emit_word_aux(): str {
//  # Pick a word length distributed according to the word lengths in the input.
//  int olen = int(sample_from_cmf(@len_cmf));
//  if (@olen > 0) {
//    olen = @olen; # If fixed-length output was requested
//  }
//
//  if (@verbose) {
//    print;
//    print "OLEN  ", olen;
//  }
//  str word = "";
//
//  # Walk through the 'start' chains to build up a word of length n.
//  str from = "_";
//  for (i = 1; i < @n; i += 1) {
//    if (@verbose) {
//      print "FROM  ", from;
//    }
//    if (i > olen) {
//      if (@verbose) {
//        print "OUT1";
//        return word;
//      }
//    }
//    if (!is_map(@start_cmfs[i][from])) {
//      if (@verbose) {
//        print "OUT2";
//      }
//      return "";
//    }
//    str letter = sample_from_cmf(@start_cmfs[i][from]);
//    word .= letter;
//    if (@verbose) {
//      print "START YIELD ", word;
//    }
//    from = word;
//  }
//
//  # Now having a word of length n, continue it using the middle-of-word chain.
//  for (int i = @n; i < olen; i += 1) {
//    if (@verbose) {
//      print "FROM  ", from;
//    }
//    if (strlen(word) >= olen) {
//      if (@verbose) {
//        print "OUT3";
//      }
//      return word;
//    }
//    if (is_absent(@middle_cmf[from])) {
//      if (@verbose) {
//        print "OUT4  ", from;
//      }
//      return "";
//    }
//    str letter = sample_from_cmf(@middle_cmf[from]);
//    if (is_absent(letter)) {
//      if (@verbose) {
//        print "OUT5";
//      }
//      return "";
//    }
//    word .= letter;
//    from = word[-@n+1:];
//    if (@verbose) {
//      print "MIDDLE YIELD", word;
//    }
//  }
//
//  if (@verbose) {
//    print "FROM  ", from;
//  }
//
//  if (is_absent(@end_cmf[from])) {
//    if (@verbose) {
//      print "OUT6";
//    }
//    return "";
//  }
//
//  # Finally, finish off the word using the end-of-word distribution.
//  str last_letter = sample_from_cmf(@end_cmf[from]);
//  if (is_absent(last_letter)) {
//    if (@verbose) {
//      print "OUT7";
//    }
//    return "";
//  }
//  word .= last_letter;
//  if (@verbose) {
//    print "END YIELD   ", word;
//  }
//
//  return word;
//}

//# ================================================================
//# See for context
//# https://miller.readthedocs.io/en/latest/randomizing-examples/#randomly-generating-jabberwocky-words
//# ================================================================
//
//# ----------------------------------------------------------------
//func compute_sum_from_histo(map histo) : num {
//  num sum = 0;
//  for (k, n in histo) {
//    sum += n;
//  }
//  return sum;
//}
//
//# ----------------------------------------------------------------
//func compute_pmf_from_histo(map histo)  : map {
//  num sum = compute_sum_from_histo(histo);
//  num cumu = 0.0;
//  map pmf = {};
//  for (k, _ in histo) {
//    num p = histo[k] / sum;
//    pmf[k] = p;
//  }
//  return pmf;
//}
//
//# ----------------------------------------------------------------
//func compute_cmf_from_pmf(map pmf)  : map {
//  num cumu = 0.0;
//  map cmf = {};
//  for (k, p in pmf) {
//    cumu += p;
//    cmf[k] = cumu;
//  }
//  return cmf;
//}
//
//# ----------------------------------------------------------------
//func compute_cmf_from_histo(map histo)  : map {
//  return compute_cmf_from_pmf(compute_pmf_from_histo(histo));
//}
//
//# ----------------------------------------------------------------
//func sample_from_cmf(var cmf) : str {
//  u = urand();
//  output = "";
//  for (k, c in cmf) {
//    output = k;
//    if (u < c) {
//      break;
//    }
//  }
//  return output;
//}

    // ----------------------------------------------------------------
    // LOGGING METHODS

    logAt0(...args) {
      this.logAt(0, ...args)
    }

    logAt1(...args) {
      this.logAt(1, ...args)
    }

    logAt2(...args) {
      this.logAt(2, ...args)
    }

    logAt3(...args) {
      this.logAt(3, ...args)
    }

    logAt(level, ...args) {
      if (this.state.logLevel >= level) {
        console.log(...args)
      }
    }

  }

  // ----------------------------------------------------------------
  const app = new JSBeeApp()
  // Expose from module visibility to top-level visibility for Console use
  window.app = app

</script>
<!-- ================================================================ -->
</body>
</html>
